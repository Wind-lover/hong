#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# POST-TRAITEMENT: CALCUL DU CHAMP DE CONTRAINTE
# Sortir l'état de contrainte à partir de résultats obtenus sous FAST, puis réécrire les
# contraintes dans le fichier .str
#
#
# Authors: Hao BAI
# Date: 24/04/2018
#
# Version:
#   - 0.0: only applicable to a annulus secion (that is to say Igx=Igy)
#   - 0.1: [20/05/2018] write stress in MPa, reform data class structure
#   - 0.2: [18/06/2018] upgrade codes to Python3
#   - 0.3: [19/10/2018] reformat the codes so that can be used as a package
#
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import csv, math, numpy, time
from math import sin, cos, radians



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class Stress(object):
    ''' I/O FAST result file .out
    
        *ATTRIBUTES*
            filename : the filename of FAST output file
            startline : the number of the row which has the channel titles
    '''
    def __init__(self, filename, gage, thetaStep=10, startline=7, echo=False):
        self.filenameInput = filename # filename including extension
        self.filebase = self.filenameInput.rstrip('.out')
        self.filenameOutput = self.filebase + '.str'
        self.fieldnamesInput = []
        self.fieldnamesOutput = []
        self.startline = startline
        self.gage = gage
        self.thetaStep = thetaStep
        self.listOfTheta = []
        self.echo = echo

        self.dataInput = dict.fromkeys(self.gage)
        self.resultField = dict.fromkeys(self.gage)
        self.dataOutput = []
        self.section = dict.fromkeys(self.gage)

        self.run()

    def run(self):
        print("Nominal stress v0.3 (October 19 2018)")
        self.__geometry()
        print("|- Importing "+self.filenameInput+" ...")
        self.open()
        print("|- Calculating the nominal stress ...")
        self.calculate(self.thetaStep)
        print("|- Saving data ...")
        self.save()

    def open(self,):
        temp = utils.readcsv(self.filenameInput)
        self.dataInput['Time'] = temp.get('Time')['Records']
        for i in self.gage: # force and moment on each node
            self.dataInput[i] = {'FLzt':[], 'MLxt':[], 'MLyt':[]}
            self.dataInput[i]['FLzt'] = temp.get('TwHt'+str(i)+'FLzt')['Records']
            self.dataInput[i]['MLxt'] = temp.get('TwHt'+str(i)+'MLxt')['Records']
            self.dataInput[i]['MLyt'] = temp.get('TwHt'+str(i)+'MLyt')['Records']

        self.dataLength = len(self.dataInput[i]['FLzt'])

    def __geometry(self):
        self.NTwGages = 9
        self.TwrGagNd = [1,3,5,8,11,14,16,18,20] # import from Elastody.dat
        self.TwrNodes = 20
        self.TowerBsHt = 0.0 # [m]
        self.TwrDraft = 0.0 # [m]
        self.TwrElevation = [0.00, 8.76, 17.52, 26.28, 35.04, 43.80, 52.56, 61.32, 70.08,\
                            78.84, 87.60] # [m]
        self.TowerHt = self.TwrElevation[-1]
        self.outerDiameter = [6.0000, 5.7870, 5.5740, 5.3610, 5.1480, 4.9350, 4.7220, \
                              4.5090, 4.2960, 4.0830, 3.8700] # [m]
        self.thickness = [0.03510, 0.03406, 0.03302, 0.03198, 0.03094, 0.02990, 0.02886, \
                          0.02782, 0.02678, 0.02574, 0.02470]
        self.innerDiameter = [i[0]-2*i[1] for i in zip(self.outerDiameter,self.thickness)]

        for i in self.gage:
            elevation, outerR, area, inertia, TwrNodeNo = self.property(i)
            self.section[i] = {'TwrNodeNo':TwrNodeNo, 'z':elevation, 'Re':outerR, \
                               'A':area, 'Igx':inertia, 'Igy':inertia}
        
        # print the geometry information of strain gages
        if self.echo is True:
            print("   ===== Tower geometry and Cross section infomation =====   ")
            print("Tower height :", self.TowerHt, "m")
            print("Total tower nodes :", self.TwrNodes)
            print("Total strain gage locations :", self.NTwGages)
            print(" Gage n° | Tower node n° | Elevation(m) | Outer Radius(m) |", \
                  "Area(m2) | 2nd moment of inertia(m4) ")
            for i in self.gage:
                print("{0:^9d}|{1:^15d}|{2:^14.2f}|{3:^17.4f}|{4:^10.4f}|{5:^27.4f}"\
                     .format(i, self.section[i]['TwrNodeNo'], self.section[i]['z'], \
                      self.section[i]['Re'],self.section[i]['A'],self.section[i]['Igx'],))

    def property(self, i):
        ''' Calculate section property
            *INPUT*
                i: tower gage number (value should be between 1 and 9) [int]
        '''
        j = self.TwrGagNd[i-1]
        elevation = self.TowerBsHt + \
                    (j-0.5) * (self.TowerHt+self.TwrDraft-self.TowerBsHt)/self.TwrNodes
        outerD = numpy.interp(elevation, self.TwrElevation, self.outerDiameter)
        innerD = numpy.interp(elevation, self.TwrElevation, self.innerDiameter)
        outerR = outerD/2
        area = math.pi*(outerD**2-innerD**2)/4
        inertia = (outerD**4-innerD**4)*math.pi/64
        return elevation, outerR, area, inertia, j

    def stress(self, i, j, theta):
        ''' Calculate the stress
            *INPUT*
                i : the number of gage node
                j : the number of line in input file (time)
                theta : the stress location
        '''
        x = self.section[i]['Re'] * cos(radians(theta))
        y = self.section[i]['Re'] * sin(radians(theta))
        stress = self.dataInput[i]['FLzt'][j] / self.section[i]['A'] \
                 - self.dataInput[i]['MLxt'][j]*y / self.section[i]['Igx'] \
                 + self.dataInput[i]['MLyt'][j]*x / self.section[i]['Igy']
        stress = stress / 1000. # convert stress into MPa
        return stress

    def __makeListOfTheta(self, thetaStep):
        self.listOfTheta = tuple(range(0, 360, thetaStep))

    def stressInPlane(self, i, j):
        # calculate the stress in plane
        for theta in self.listOfTheta:
            stress = self.stress(i,j,theta)            
            self.resultField[i][j][theta] = stress

    def stressField(self):
        for i in self.gage:            
            self.resultField[i] = dict.fromkeys(range(self.dataLength))
            for j in range(self.dataLength):
                self.resultField[i][j] = {}
                self.stressInPlane(i,j)

    def __writeToRow(self):
        # Prepare the row that will be written
        for j in range(self.dataLength):
            row = {}
            row['Time      '] = str("{:>10.4f}").format(self.dataInput['Time'][j])
            for i in self.gage:
                for theta in self.listOfTheta:
                    header = str("TwHt{0}@{1:<4d}").format(i, theta)
                    row[header] = str("{:>10.3E}").format(self.resultField[i][j][theta])
            self.dataOutput.append(row)
    
    def calculate(self, thetaStep):
        self.__makeListOfTheta(thetaStep)
        self.stressField()
        self.__writeToRow()

    def save(self,):
        # Create the title line
        self.fieldnamesOutput.append('Time      ')
        for i in self.gage:
            for theta in self.listOfTheta:
                header = str("TwHt{0}@{1:<4d}").format(i, theta)
                self.fieldnamesOutput.append(header)
        # Create the unit line
        self.fieldunitsOutput = dict.fromkeys(self.fieldnamesOutput, "{:^10}".format(
                                                                                 "(MPa)"))
        self.fieldunitsOutput['Time      '] = "{:^10}".format("(s)")
        # Save result to the file
        with open(self.filenameOutput, 'wt') as f:
            # write something before data (licens, instructions, explanations, etc.)
            for i in range(self.startline-1):
                f.write("\n")
            # prepare csv writer
            datawriter=csv.DictWriter(f, delimiter='\t', fieldnames=self.fieldnamesOutput)
            datawriter.writeheader() # channel titles
            datawriter.writerow(self.fieldunitsOutput) # channel units
            for row in self.dataOutput: # channel data
                datawriter.writerow(row)



#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    tik=time.time()
    mydata=Stress(filename='DLC1.2_NTM_25mps.out', gage=[1,9], thetaStep=30)
    tok=time.time()
    print(tok-tik)
    # for i in range(3,27,2):
    #     TIK = time.time()
        
    #     filename = 'DLC1.2_NTM_'+str(i)+'mps.out'
    #     mydata = Stress(filename, 7, [1,9])
        
    #     del mydata

    #     TOK = time.time()
    #     elapsedTime = TOK - TIK
    #     print("|- Finished! "+str("{:.2f}").format(elapsedTime)+"s used.\n")



#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
