#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# FATIGUE LIFE ASSESSMENT
# Sortir l'état de contrainte à partir de résultats obtenus sous FAST, puis réécrire les
# contraintes dans le fichier .str
#
#
# Authors: Hao BAI
# Date: 19/10/2018
#
# Version:
#   - 0.0: get S-N curves with Goodman correction (retrieve ancient sn.py)
#   - 0.1: Rainflow counting (retrieve ancient count.py)
#
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
from collections import namedtuple
from math import log10
import rainflow



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class DNVGL(object):
    ''' DNVGL-RP-C203 (Edition April 2016)
        << Recommended Practice - Fatigue design of offshore steel structures >>
        *ATTRIBUTES*
            SNcurve : DNVGL notation of S-N curve
            air : S-N curves in air (True[default]: in air; False: in seawater)
            cp : cathodic protection (only valide in seawater, False[default])
            Goodman : Goodman correction (False[default])
    '''
    def __init__(self, SNcurve, air=True, cp=False, Goodman=(False, 0.0), material=''):
        self.SNcurve = SNcurve
        self.air = air
        self.cp = cp
        self.Goodman = Goodman
        self.material = material

        self.__curves = dict.fromkeys(('B1', 'B2', 'C', 'C1', 'C2', 'D', 'E', 'F', 'F1',
                                       'F3','G','W1', 'W2', 'W3'))
        self.__materials = dict.fromkeys(('C','C-Mn'))
        self.run()

    def run(self):
        # print "S-N curve v0.0 (June 3 2018)"
        self.__build()
        self.__choose()

    def __build(self):
        '''
        Build database
        '''
        # §1.2.1 steel forgings in air, page 9
        # Table D-1 Design S-N curves for steel forgings in air, page 168
        # Rm : ultimate tensile strength = résistance à la traction (MPa)
        # Re : yield strength = limite d'élasticité (MPa)
        record = namedtuple('Material', 'Rm_air, Re_air, Rm_sea, Re_sea')
        self.__materials['C'] = record(862, 724, 793, 689)
        self.__materials['C-Mn'] = record(None, 960, None, 690)

        # Table 2-1 S-N curves in air, page 23
        # m : negative inverse slope of S-N curve
        # a : intercept of log N-axis by S-N curve
        # N : number of cycles to failure at fatigue limite = 10^7
        # Sf : fatigue limite at 10^7 cycles (MPa)
        record = namedtuple('SNcurve', ('air, cp, m1, a1, m2, a2, N, Sf, k, SCF'))
        self.__curves['B1'] = record(True, None, 4.0, 15.117, 5.0, 17.146, 1e7, 106.97, 0.00, None)
        self.__curves['B2'] = record(True, None, 4.0, 14.885, 5.0, 16.856, 1e7,  93.59, 0.00, None)
        self.__curves['C']  = record(True, None, 3.0, 12.592, 5.0, 16.320, 1e7,  73.10, 0.05, None)
        self.__curves['C1'] = record(True, None, 3.0, 12.449, 5.0, 16.081, 1e7,  65.50, 0.10, None)
        self.__curves['C2'] = record(True, None, 3.0, 12.301, 5.0, 15.835, 1e7,  58.48, 0.15, None)
        self.__curves['D']  = record(True, None, 3.0, 12.164, 5.0, 15.606, 1e7,  52.63, 0.20, 1.00)
        self.__curves['E']  = record(True, None, 3.0, 12.010, 5.0, 15.350, 1e7,  46.78, 0.20, 1.13)
        self.__curves['F']  = record(True, None, 3.0, 11.855, 5.0, 15.091, 1e7,  41.52, 0.25, 1.27)
        self.__curves['F1'] = record(True, None, 3.0, 11.699, 5.0, 14.832, 1e7,  36.84, 0.25, 1.43)
        self.__curves['F3'] = record(True, None, 3.0, 11.546, 5.0, 14.576, 1e7,  32.75, 0.25, 1.61)
        self.__curves['G']  = record(True, None, 3.0, 11.398, 5.0, 14.330, 1e7,  29.24, 0.25, 1.80)
        self.__curves['W1'] = record(True, None, 3.0, 11.261, 5.0, 14.101, 1e7,  26.32, 0.25, 2.00)
        self.__curves['W2'] = record(True, None, 3.0, 11.107, 5.0, 13.845, 1e7,  23.39, 0.25, 2.25)
        self.__curves['W3'] = record(True, None, 3.0, 10.970, 5.0, 13.617, 1e7,  21.05, 0.25, 2.50)


    def __choose(self):
        # Without Goodman correction
        curve = self.__curves.get(self.SNcurve)
        if curve is None:
            print("[Error] No such S-N curve !")
            exit()
        else:
            self.curveRef = curve

        # With Goodman correction: by using ultimate tensile strength
        if self.Goodman[0] is True:
            # Get material
            if self.material is '':
                material=self.__materials.get('C') # default material
            else:
                material=self.__materials.get(self.material)
                if material is None:
                    print("[Error] No such material !")
                    exit()
            # Sfa : alternating stress (MPa)
            if self.air is True:
                Sfa = curve.Sf * (1 - self.Goodman[1]/material.Rm_air)
            else:
                Sfa = curve.Sf * (1 - self.Goodman[1]/material.Rm_sea)
            # Change a1 and a2
            a1 = log10(curve.N) + curve.m1*log10(Sfa)
            a2 = log10(curve.N) + curve.m2*log10(Sfa)
            self.curveGoodman = curve._replace(a1=a1, a2=a2, Sf=Sfa)

    def whichSN(self, stressRange, curveConf):
        if stressRange >= curveConf.Sf:
            N = 10.0**(curveConf.a1 - curveConf.m1*log10(stressRange))
        elif stressRange < curveConf.Sf:
            N = 10.0**(curveConf.a2 - curveConf.m2*log10(stressRange))
        return N

    def sn(self, stressRange):
        if self.Goodman[0] is True:
            return self.whichSN(stressRange, self.curveGoodman)
        else:
            return self.whichSN(stressRange, self.curveRef)
    
    def whichNS(self, cycle, curveConf):
        if cycle <= curveConf.N:
            stressRange = 10.0**((curveConf.a1-log10(cycle))/curveConf.m1)
        elif cycle > curveConf.N:
            stressRange = 10.0**((curveConf.a2-log10(cycle))/curveConf.m2)
        return stressRange

    def ns(self, cycle):
        if self.Goodman[0] is True:
            return self.whichNS(cycle, self.curveGoodman)
        else:
            return self.whichNS(cycle, self.curveRef)

    def plotSN(self):
        '''
        Plot S-N curve
        '''
        from matplotlib import pyplot as plt

        X = range(int(1e4), int(1e8+1), int(1e6))
        Y = []
        [Y.append(self.whichNS(x, self.curveRef)) for x in X]
        plt.loglog(X,Y, 'b', label="S-N curve") # Plot S-N curve
        x_reversal = self.curveRef.N
        y_reversal = self.whichNS(self.curveRef.N, self.curveRef)
        plt.plot(x_reversal, y_reversal, 'b*') # Plot reversal point at 10^7
        coordinates = r"$(10^{0:.0f},{1:.2f})$".format(log10(x_reversal), y_reversal)
        plt.text(x_reversal, y_reversal, coordinates, color='b')

        # Plot S-N curve with Goodman correction
        if self.Goodman[0] is True:
            Y = []
            [Y.append(self.whichNS(x, self.curveGoodman)) for x in X]
            plt.loglog(X,Y, 'r', label="S-N curve with Goodman") # Plot S-N curve
            x_reversal = self.curveGoodman.N
            y_reversal = self.whichNS(self.curveGoodman.N, self.curveGoodman)
            plt.plot(x_reversal, y_reversal, 'r*') # Plot reversal point at 10^7
            coordinates = r"$(10^{0:.0f},{1:.2f})$".format(log10(x_reversal), y_reversal)
            plt.text(x_reversal, y_reversal, coordinates, verticalalignment='top', \
                     horizontalalignment='right', color='r', )

        # Make title, legend, label and so on
        if self.air is True:
            title = "S-N curve : "+self.SNcurve+" in air"
        elif self.cp is True:
            title = "S-N curve : "+self.SNcurve+" in seawater with cathodic protection"
        else:
            title = "S-N curve : "+self.SNcurve+" in seawater without cathodic protection"
        plt.title(title)
        plt.legend()
        plt.xlabel("Number of cycles")
        plt.ylabel("Stress range (MPa)")
        plt.axis([1e4, 1e8, 1e1, 1e3]) # plt.xlim(1e4, 1e8)
        plt.grid(True, which='both') # show 'major', 'minor' or 'both' tick grids
        plt.show()


class Count(object):
    ''' Rainflow counting over every spot on each tower gage
    '''
    def __init__(self, filename, spotNames=None, echo=False):
        self.filename = filename
        self.spotNames = spotNames
        self.echo = echo

        self.dataInput = {}
        self.rainflowData = {}

        self.run()

    def run(self):
        print("Rainflow counting v0.2 (October 20 2018)")
        print("|- Importing "+self.filename+" ...")
        self.open()
        print("|- Counting Rainflow cycles ...")
        self.count()
        if self.echo: self.show()
        print("|- [OK] Rainflow count finished !")

    def open(self):
        self.dataInput = utils.readcsv(self.filename, unitrow=8)

        if self.spotNames is None: # count cycles on every spot
                print("|- [ALERT] Every stress history will be used to count Rainflow " +
                      "cycles. Try to use <class finding> in order to extract firstly " +
                      "fatigue stress and reduce time consumption")
                spotNames = self.dataInput.getkeys()
                spotNames.pop(0) # remove "Time" column
                self.spotNames = spotNames
        elif isinstance(self.spotNames[0], int):
            spotNames = []
            for spot in self.spotNames:
                for name in self.dataInput.getkeys()[1:]:
                    if name[4] == str(spot):
                        spotNames.append(name)
                # print("|- [ALERT] The input file doesn't contain "+"TwHt"+str(i))
                # TO BE COMPLETED
            self.spotNames = spotNames

    # Rainflow counting
    def count(self):
        for spot in self.spotNames:
            self.rainflowData[spot] = {'Cycle':[], 'Range':[], 'Mean':[]}
            for valley, peak, cycle in rainflow.extract_cycles(self.dataInput.get(spot)['Records']):
                rangeValue = peak - valley
                meanValue = (peak+valley)/2
                self.rainflowData[spot]['Cycle'].append(cycle)
                self.rainflowData[spot]['Range'].append(rangeValue)
                self.rainflowData[spot]['Mean'].append(meanValue)

    # Showing result table in screen
    def show(self):
        for spot in self.spotNames:
            data = self.rainflowData[spot]
            length = len(data['Cycle'])
            print('========== '+spot+' ==========')
            print('Num. of Cycles','Stress Range (MPa)','Stess Mean (MPa)')
            for i in range(length):
                print(data['Cycle'][i], data['Range'][i], data['Mean'][i])
            print(' ')

class Fatigue(object):
    ''' Calculate cumulative damage
        *ATTRIBUTES*
    '''
    def __init__(self, filename, spotNames=None):
        if spotNames is None: #[Default] run rainflow counting on every local spots
            self.RFdata = Count(self.fatigueStress)
        elif isinstance(spotNames[0], int): # read a serie of gage nodes 
            self.RFdata = Count(filename, spotNames)
        elif isinstance(spotNames[0], str): # read a list of local spots
            self.RFdata = Count(filename, spotNames)
        else:
            print("[Error] Wrong spot index name or gage node nubmer !")
            exit()
        
        self.filename = filename
        self.spotNames = self.RFdata.rainflowData.keys()
        # self.spotNames.sort()
        self.damage = dict.fromkeys(self.spotNames)
        self.lifetime = 20*365*24*6 # Wind tower's designed lifetime per 10min
        

    def assessAllStressSpot(self):
        print("Spotname", "Damage", "Damege during lifetime")
        for spot in self.spotNames:
            self.damage[spot] = {'n':[], 'N':[], 'D':[], 'Dtotal':0.0, 'Dlife':0.0}
            self.damage[spot]['n'] = self.RFdata.rainflowData[spot]['Cycle']
            ranges = self.RFdata.rainflowData[spot]['Range']
            means = self.RFdata.rainflowData[spot]['Mean']
            length = len(ranges)

            for i in range(length):
                n = self.damage[spot]['n'][i]
                curve = DNVGL('B1', Goodman=(True, means[i]))
                N = curve.sn(ranges[i])
                self.damage[spot]['N'].append(N)
                D = n/N
                self.damage[spot]['D'].append(D)
                self.damage[spot]['Dtotal'] = self.damage[spot]['Dtotal'] + D

            self.damage[spot]['Dlife'] = self.damage[spot]['Dtotal'] * self.lifetime
            print(spot," : ",self.damage[spot]['Dtotal'],", ",self.damage[spot]['Dlife'])

    def save(self, filename=None):
        if filename is None: filename = self.filename + ".dam"
        print("|- Saving data to "+filename)
        with open(filename, 'wb') as f:
            pickle.dump(self.damage, f)

#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    test = 3
    # Testing DNGVL class
    if test == 1:
        curve = DNVGL('B1', Goodman=(True, 20.0))
        print(curve.sn(curve.ns(1e7)))
        curve.plotSN()
        print('|- OK')

    # Testing Count class
    if test == 2:
        myCount3 = Count('DLC1.2_NTM_25mps.str', spotNames=[1,5,9])

    # Tesint Fatigue class
    if test == 3:
        analysis = Fatigue('DLC1.2_NTM_25mps.str', [1,4,9])
        analysis.assessAllStressSpot()


#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
