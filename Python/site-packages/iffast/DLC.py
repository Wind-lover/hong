#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# DLC
#
# Authors: Hao BAI (hao.bai@insa-rouen.fr)
# Version: 0.0
# Date: 28/10/2018
#
# Comments:
#     - 0.0: Create a general class for preparing FAST input scripts
#     - 0.1: Add DLC11 class designed for DLC1.1
#     - 0.2: create a supervising function for multiprocess
# Description:
#     Prepare a general class for DLC input scripts
#     Customize each DLC input script
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#-----------------------------------------------------------------------------------------
#                                        MODULES
#-----------------------------------------------------------------------------------------
#============================== Modules Personnels ==============================
from tools import utils
#import sys, IPython # to colorize traceback errors in terminal
#sys.excepthook = IPython.core.ultratb.ColorTB()
#============================== Modules Communs ==============================
import re
import json
import time
import platform
import fileinput # iterate over lines from multiple input files
import shutil # high-level file operations
import subprocess # call a bash command e.g. 'ls'
import multiprocessing # enable multiprocessing
from pathlib import Path



#-----------------------------------------------------------------------------------------
#                                    CLASS DEFINITION
#-----------------------------------------------------------------------------------------
class DLC(object):
    ''' Customize FAST input scripts for DLC
        *ATTRIBUTES*
    '''
    def __init__(self, seed, case, outputFolder, moveSource, echo):
        self.seed =  seed
        self.case = case
        self.outputFolder = outputFolder
        self.moveSource = moveSource
        self.echo = echo
        # Get OS platform name
        self._system = {'Linux':'FAST_glin64', 'Darwin':'FAST_gdar64'}
        self._fastName = self._system.get(platform.system())
        # some fixed path
        self.outputPath = Path(
                            '~/Eolien/Parameters/Python/{0}/Output/{0}'.format(self.case))
        self.outputPath = self.outputPath.expanduser()
        self.inputPath = Path('~/Eolien/Parameters/Python/{}'.format(self.case))
        self.inputPath = self.inputPath.expanduser()
        self.fastFile = '{}_{}_{}mps.fst'.format(self.case, self.seed[0], self.seed[1])
        self.inflowFile='{}_{}_{}mps.IW.dat'.format(self.case, self.seed[0], self.seed[1])
        self.servoFile = ''


    def _change_wind_profil(self):
        # InflowWind input script --------------------------------------------------------
        filename = self.inputPath.joinpath(self.inflowFile)
        data = filename.read_text()
        data = self._change_string(data, 'Filename')

        filename = self.inputPath.joinpath('{}_{}_{}mps_{}.IW.dat'.format(self.case, self.seed[0], self.seed[1], self.seed[2]))
        filename.write_text(data)
        self.inflowFile = filename # update Inflow .dat file

        # FAST input script --------------------------------------------------------------
        filename = self.inputPath.joinpath(self.fastFile)
        data = filename.read_text()
        data = self._change_string(data, 'InflowFile')
        
        filename = self.inputPath.joinpath('{}_{}_{}mps_{}.fst'.format(self.case, self.seed[0], self.seed[1], self.seed[2]))
        filename.write_text(data)
        self.fastFile = filename # update .fst file

    def _change_string(self, text, keyword):
        if keyword == 'Filename':
            old = "{}/{}_{}mps.bts".format(self.case, self.seed[0], self.seed[1])
            new = "{}/{}_{}mps_{}.bts".format(self.case, self.seed[0], self.seed[1],
                                              self.seed[2])
            text = re.sub(old, new ,text)

        if keyword == 'InflowFile':
            old = "{}_{}_{}mps.IW.dat".format(self.case, self.seed[0], self.seed[1])
            new = "{}_{}_{}mps_{}.IW.dat".format(self.case, self.seed[0], self.seed[1],
                                                 self.seed[2])
            text = re.sub(old, new ,text)
        return text

    def _fast(self, silence):
        ''' Call FAST program
        '''
        with utils.cd('~/Eolien/FAST'):
            command = './{0} {1}'.format(self._fastName, str(self.fastFile))
            try:
                if silence:
                    output = subprocess.check_output([command], shell=True)
                else:
                    output = subprocess.check_call([command], shell=True)
                    # Note:
                    # When shell=False, args[:] is a command line to execute
                    # When shell=True, args[0] is a command line to execute and args[1:] 
                    # is arguments to sh
            except subprocess.CalledProcessError as error:
                # print('error: \n', error)
                errorMessage = str(error.output) # works only when silence = TRUE
                wrong = True
            except Exception as e:
                raise e
            else:
                wrong = False
        # if an error occurs during execution, write output message to file
        if wrong:
            directory = self.inputPath.joinpath('log')
            directory.mkdir(exist_ok=True) # create new folder if non-exist
            filename = directory.joinpath('{}.bug'.format(self.seed[2]))
            filename.write_text(errorMessage)
            raise Exception('|- [ERROR] FAST has an error for simulation {}, please see report in {}'.format(self.seed, filename))

    def _move(self):
        ''' Move and rename files
        '''
        # FAST output file (.out) to output folder ---------------------------------------
        source = self.inputPath.joinpath('{}'.format(self.outputFolder), '{}_{}_{}mps_{}.out'.format(self.case, self.seed[0],self.seed[1], self.seed[2]))

        destination = self.outputPath.joinpath('{}'.format(self.outputFolder), '{}_{}mps_{}.out'.format(self.seed[0], self.seed[1], self.seed[2]))
        source.replace(destination)
        # TurbSim wind file (.bts) to subfolder ------------------------------------------
        if self.moveSource:
            source = self.inputPath.joinpath('Wind/{}/{}_{}mps_{}.bts'.format(self.case, self.seed[0], self.seed[1], self.seed[2]))
            filename = source.name

            destination = self.inputPath.joinpath('Wind/{}/finished'.format(self.case))
            destination.mkdir(exist_ok=True) # create new folder if non-exist
            source.replace(destination.joinpath(filename))


class DLC11(DLC):
    ''' DLC1.1 NTM
        Mean wind speed: Vcut-in <= Vhub <= Vcut-out
        *ATTRIBUTES*
    '''
    def __init__(self, seed, case='DLC1.1', outputFolder='', moveSource=False, echo=False):
        super(DLC11, self).__init__(seed, case, outputFolder, moveSource, echo)
        
    def run(self, silence=False):
        self._change_wind_profil()
        self._fast(silence)
        self._move()



#-----------------------------------------------------------------------------------------
#                                  FUNCTION DEFINITION
#-----------------------------------------------------------------------------------------
def get_DLC11(seed, outputFolder='', moveSource=False, silence=False, echo=False):
    temp = DLC11(seed=seed, outputFolder=outputFolder, moveSource=moveSource, echo=echo)
    temp.run(silence=silence)
    return seed

def get_DLC11_multiprocess(list_seed, outputFolder='', moveSource=False, silence=False,
                           echo=False):
    print('DLC v0.2 (November 5 2018)')
    print('========== Multiprocessing Mode ==========')
    # prepare a callback function
    length = len(list_seed)
    completed = []
    def printer(seed):
        pos = list_seed.index(seed) + 1
        completed.append(seed)
        rest = length - len(completed)
        hour, minute = time.strftime("%H,%M").split(',')
        print('|- [{}/{}] Simulation for {} wind at {} m/s with seed ID {} is terminated '
              'at {}:{}. {} tasks waiting to be completed ...'.format(pos, length, seed[0],
              seed[1], seed[2], hour, minute, rest))
    # begin multiprocessing
    pool = multiprocessing.Pool()
    [pool.apply_async(get_DLC11, args=(seed, outputFolder, moveSource, silence, echo),
     callback=printer, error_callback=utils.handle_error) for seed in list_seed]
    pool.close()
    pool.join()



#-----------------------------------------------------------------------------------------
#                                     MAIN FUNCTION
#-----------------------------------------------------------------------------------------
@utils.timer
def main():
    # Load seeds
    with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'):
        with open('6seeds.json', 'r') as f:
            seeds = json.loads(f.read())

    liste = []
    [liste.append(s) for s in seeds if s[0] == "NTM"]
    seeds = liste[:1]

    # ----- Running on single processor
    # get_DLC11(seeds[0])
    get_DLC11(['NTM','3','1480621087'], silence=1)
    # get_DLC11(['NTM','13','-1491944232'], silence=False)


#-----------------------------------------------------------------------------------------
#                                      RUNNING TEST
#-----------------------------------------------------------------------------------------
if __name__ == '__main__':
        main()
