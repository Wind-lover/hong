#!/usr/bin/env python
# -*- coding: utf-8 -*-

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Post-processing the results from fatigue analysis
#
#
# Authors: Hao BAI
# Date: 29/10/2018
#
# Version:
#   - 0.0: Initial version reserved for DLC1.1
#
# Comments:
# 
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!------------------------------------------------------------------------------
#*============================== Modules Personnels ============================
from tools import utils
from pygraph import chart
#*============================== Modules Communs ==============================
from matplotlib import pyplot as plt
from matplotlib.ticker import PercentFormatter
import json
import math
import numpy as np
import collections
import statistics as stats



#!------------------------------------------------------------------------------
#!                                         CLASS
#!------------------------------------------------------------------------------
class Damage(object):
    """ Find extrema in FAST output file
        Attributes:
                      
        Methods:
        
    """
    def __init__(self, filebase, echo):
        # attributes from input
        self.filebase = filebase
        self.echo = echo
        # new attributes
        self.dataInput = None
        self.maxDamage = None
        self.maxSpot = None
        # run methods
        self.load()
        self.getMax()

    def load(self):
        with open(self.filebase+'.dam', 'r') as f:
            self.dataInput = json.loads(f.read())

    def getMax(self):
        allDamages = [value['Dcumulate'] for value in self.dataInput.values()]
        self.maxDamage = max(allDamages)
        self.maxSpot = [key for (key, value) in self.dataInput.items() 
                        if value['Dcumulate'] == self.maxDamage][0]


class Analysis(object):
    """ Cross wind speed study
    """
    def __init__(self, seeds, folder, echo):
        self.seeds = seeds
        self.folder = folder
        self.echo = echo

        self.listOfSpeed = []
        self.dataInput = collections.OrderedDict()

        self.run()

    def run(self):
        print('Post-processing: sensebility analysis of fatigue damage v0.1 (18 November 2018)')
        print('|- Loading file ...')
        self._load()
        print('|- Calculating damage on spot for all wind speeds ...')
        self._damageOnSpot()
        print('|- Calculating mean damage for all wind speeds ...')
        self._meanDamageForAllSpeeds()

    def _load(self):
        # recover list of mean wind speeds
        listOfSpeed = list(set([int(s[1]) for s in self.seeds]))
        listOfSpeed.sort()
        self.listOfSpeed = [str(v) for v in listOfSpeed]
        # initiate structure of input data
        for v in self.listOfSpeed:
            self.dataInput[v] = {'InputDamageFile':collections.deque(),
                                 'MaxSpots':collections.deque(),
                                 'Occurence':[],
                                 'MaxSpot':'',
                                 'MeanDamages':collections.deque()}
        # read data from file
        for s in self.seeds:
            d = Damage('{}/{}_{}mps_{}'.format(self.folder, s[0], s[1], s[2]), False)
            self.dataInput[s[1]]['InputDamageFile'].append(d)
            self.dataInput[s[1]]['MaxSpots'].append(d.maxSpot)
    
    def _damageOnSpot(self):
        for v in self.listOfSpeed:
            data = self.dataInput[v]['MaxSpots']
            spotNames = set(data)
            self.dataInput[v]['Occurence'] = [(name, data.count(name)) for name
                              in spotNames]
            self.dataInput[v]['MaxSpot'] = max(self.dataInput[v]['Occurence'],
                                               key=lambda x:x[1])
        
        if self.echo:
            print('Wind speed (m/s)\tSpot\tOccurence (/{})'.format(
                                              int(len(self.seeds)/len(self.listOfSpeed))))
            for v in self.listOfSpeed:
                print('{}\t{}\t{}'.format(v, self.dataInput[v]['MaxSpot'][0],
                                                         self.dataInput[v]['MaxSpot'][1]))
    
    def plotDamageOnSpot(self, speed, spot, axisInput=None, bins=20, xlim=[],
                         normed=True):
        data = collections.deque()
        data = [file.dataInput[spot]['Dcumulate']
                           for file in self.dataInput[speed]['InputDamageFile']]
        if axisInput is None:
            fig, axis = plt.subplots()
        else:
            axis = axisInput
        # X-axis is normalized to its local max. damage
        if normed:
            yMax = max(data)
            data = [y/yMax for y in data]
        # Y-axis is normalized to the total number of runs
        N, bins, patches = axis.hist(data, bins=bins,
                                     weights=np.ones(len(data))/len(data))
        axis.yaxis.set_major_formatter(PercentFormatter(1)) # convert to percentage
        axis.set_ylim(0, 1)
        if normed:
            axis.set_xlim(0, 1)
            axis.set_xticks(np.arange(0, 1.1, 0.1))
            axis.text(0.80, 0.05, 'max. = {:.2e}'.format(yMax), ha='center',
                      va='center', transform=axis.transAxes)
        else:
            axis.ticklabel_format(style='sci', scilimits=(-3,4), axis='x')
            if xlim != []:
                axis.set_xlim(xlim[0], xlim[1])
                axis.set_xticks(np.arange(xlim[0], xlim[1]+xlim[2], xlim[2]))
        # Set axis properties
        if axisInput is None:
            axis.set_title('Distribution of damage at wind speed {} m/s on'
                           ' section spot {}'.format(speed, spot))
            axis.set_xlabel('10-min cumulative damage')
            axis.set_ylabel('Probability')
            plt.show()
        else:
            axis.set_title('{} m/s {}°'.format(speed, spot), pad=-15)

    def plotDamageForAllSpeeds(self, bins=20, shareXaxis=False, shareYaxis=True,
                               xlim=[], normed=True, toPDF=[]):
        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis, tight_layout=False)
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            spot = self.dataInput[v]['MaxSpot'][0]
            self.plotDamageOnSpot(v, spot, ax, bins, xlim, normed)
        # Common axes lables
        fig.suptitle('Distribution of damage at different wind speed')
        if normed:
            fig.text(0.5, 0.03, '10-min cumulative damage (normolized to local '             'maximum)', ha='center', va='center')
        else:
            fig.text(0.5, 0.03, '10-min cumulative damage', ha='center', va='center')
        fig.text(0.02, 0.5, 'Probability', ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.10, right=0.94, top=0.94, wspace=0.14, hspace=0.14)

    def _meanDamageOnGage(self, speed):
        data = collections.OrderedDict()
        # initiate data structure
        for key in self.dataInput[speed]['InputDamageFile'][0].dataInput.keys():
            data[key] = collections.deque()
        # get damage values
        for file in self.dataInput[speed]['InputDamageFile']:
            for (key, value) in file.dataInput.items():
                data[key].append(value['Dcumulate'])
        # calculate mean value
        for (key, value) in data.items():
            mean = sum(value)/len(value)
            self.dataInput[speed]['MeanDamages'].append((key,mean))

    def _meanDamageForAllSpeeds(self):
        [self._meanDamageOnGage(v) for v in self.listOfSpeed]

    def plotMeanDamageOnGage(self, speed, gage, axisInput=None, normed=True):
        # get and sort data
        temp = collections.deque()
        for elem in self.dataInput[speed]['MeanDamages']:
            if elem[0][4] == gage:
                temp.append( (math.radians(float(elem[0][6:])), elem[1]) )
        temp = list(temp)
        temp.sort()
        # decompose to vectors for plotting
        X = collections.deque()
        Y = collections.deque()
        for elem in temp:
            X.append(elem[0])
            Y.append(elem[1])
        X.append(X[0]) # in order to close circle in radar graph
        Y.append(Y[0])
        # normolize the average of cumulative damage by its maximum value
        if normed:
            yMax = max(Y)
            Yorigin = Y
            Y = [y/yMax for y in Y]
        # plot in polar coordinates
        if axisInput is None:
            axis = plt.subplot(111, polar=True)
        else:
            axis = axisInput
        # plot data
        axis.plot(X, Y, 'o-', markersize=3)
        if normed: axis.set_rlim(0, 1)
            # axis.set_rmax(1e-7)
        #*common settings of axes
        axis.set_rlabel_position(-90) # change radius labels location [degree]
        axis.set_thetagrids(range(0,360,30)) # change theta gridlines
        # if you want to change location of θ = 0°:
        # axis.set_theta_offset(math.pi / 2)
        # axis.set_theta_direction(-1)
        # if you want to change radius labels angle
        # axis.tick_params(axis='y', rotation=-60)
        if axisInput is None:
            axis.fill(X, Y)
            axis.set_title('Distribution of mean damage at wind speed {} m/s on'
                           'tower gage {}'.format(speed, gage))
            # axis.set_xlabel('Angle of θ (°)')
            plt.show()
        else:
            axis.set_title('{} m/s gage {}'.format(speed, gage), pad=-30)
        if normed:
            axis.text(1.15, 0.1, 'max. = {:.2e}'.format(yMax), ha='center',
                      va='center', transform=axis.transAxes)
        return (X, Yorigin)

    def plotMeanDamageForAllSpeeds(self, shareXaxis=False, shareYaxis=True,
                                   toPDF=[]):

        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis,
                        tight_layout=False, subplot_kw=dict(projection='polar'))
        axes = [axis for ax in axes for axis in ax]
        
        # The minor subplots
        damages = []
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            spot = self.dataInput[v]['MaxSpot'][0] # choose gage of max damage
            damage = self.plotMeanDamageOnGage(v, spot[4], ax)
            damages.append(damage)
        # Common axes lables
        # plt.subplots_adjust(left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
        fig.suptitle('Distribution of mean damage at different wind speed')
        fig.text(0.5, 0.03, 'Perimeter: spot angle θ (°)', ha='center', va='center')
        fig.text(0.02, 0.5, 'Radius: Average of cumulative damage in {} runs '
                 '(normolized to local maximum)'.format(int(len(self.seeds)/len(self.listOfSpeed))),
                 ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
        return damages

    def compareMeanDamageOnGage(self, speed, gage, axisInput, damageInput, normed=True):
        # get and sort data
        temp = collections.deque()
        for elem in self.dataInput[speed]['MeanDamages']:
            if elem[0][4] == gage:
                temp.append( (math.radians(float(elem[0][6:])), elem[1]) )
        temp = list(temp)
        temp.sort()
        # decompose to vectors for plotting
        X = collections.deque()
        Y = collections.deque()
        for elem in temp:
            X.append(elem[0])
            Y.append(elem[1])
        X.append(X[0]) # in order to close circle in radar graph
        Y.append(Y[0])
        # normolize the average of cumulative damage by its maximum value
        if normed:
            yMax = max(max(Y), max(damageInput[1]))
            Y = [y/yMax for y in Y]
            Ycompared = [y/yMax for y in damageInput[1]]
        else:
            Ycompared = damageInput[1]
        # plot in polar coordinates
        if axisInput is None:
            axis = plt.subplot(111, polar=True)
        else:
            axis = axisInput
        # plot data
        axis.plot(X, Y, '-', linewidth=1, label='1000 runs')
        axis.plot(damageInput[0], Ycompared, '-', linewidth=1, label='100 runs')
        axis.fill_between(X, Y, Ycompared, alpha=0, edgecolor='gray', hatch='xxxx') # facecolor='tab:grey',
        if normed: axis.set_rlim(0, 1)
        #*common settings of axes
        axis.set_rlabel_position(-90) # change radius labels location [degree]
        axis.set_thetagrids(range(0,360,30)) # change theta gridlines
        if axisInput is None:
            axis.fill(X, Y)
            axis.set_title('Distribution of mean damage at wind speed {} m/s on'
                           'tower gage {}'.format(speed, gage))
            plt.show()
        else:
            axis.set_title('{} m/s gage {}'.format(speed, gage), pad=-30)
        if normed:
            axis.text(1.15, 0.1, 'max. = {:.2e}'.format(yMax), ha='center',
                      va='center', transform=axis.transAxes)

    def compareMeanDamageForAllSpeeds(self, damageInput, shareXaxis=False,
                                      shareYaxis=True, normed=True, toPDF=[]):
        fig, axes = plt.subplots(3, 4, sharex=shareXaxis, sharey=shareYaxis,
                        tight_layout=False, subplot_kw=dict(projection='polar'))
        axes = [axis for ax in axes for axis in ax]
        # The minor subplots
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            spot = self.dataInput[v]['MaxSpot'][0] # choose gage of max damage
            damage = self.compareMeanDamageOnGage(v, spot[4], ax, normed=normed,
                                                  damageInput=damageInput[ind])
        # Common axes lables
        fig.legend(['1000 runs', '100 runs'])
        fig.suptitle('Compare: Distribution of mean damage between 1000 runs '
                     'and 100 runs')
        fig.text(0.5, 0.03, 'Perimeter: spot angle θ (°)', ha='center', va='center')
        fig.text(0.02, 0.5, 'Radius: Average of cumulative damage (normolized '
                 'to local maximum)'.format(int(len(self.seeds)/len(self.listOfSpeed))),
                 ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)

    def plotMeanDamageOfTower(self, speed, shareXaxis=False, shareYaxis=True, normed=True,
                                   toPDF=[]):
        fig, axes = plt.subplots(3, 3, sharex=shareXaxis, sharey=shareYaxis,
                        tight_layout=False, subplot_kw=dict(projection='polar'))
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            self.plotMeanDamageOnGage(speed, str(ind+1), ax, normed)
        # Common axes lables
        # plt.subplots_adjust(left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
        fig.suptitle('Distribution of mean damage at wind speed {} m/s'
                     .format(speed))
        fig.text(0.5,0.03,'Perimeter: spot angle θ (°)',ha='center',va='center')
        if normed:
            fig.text(0.02,0.5,'Radius: Average of cumulative damage in {} runs '
                     '(normolized to local maximum)'.format(int(len(self.seeds)/
                     len(self.listOfSpeed))), ha='center', va='center',
                     rotation='vertical')
        else:
            fig.text(0.02,0.5,'Radius: Average of cumulative damage in {} runs '
                     .format(int(len(self.seeds)/len(self.listOfSpeed))),
                     ha='center', va='center', rotation='vertical')
        chart.draw(fig, toPDF, left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)



#!------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!------------------------------------------------------------------------------



#!------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!------------------------------------------------------------------------------
def main():
    essai = 2

    if essai == 1:
        test = Damage('NTM_25mps', False)
        print(test.maxDamage, test.maxSpot)

    if essai == 2:
        with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'):
            with open('100seeds.json', 'r') as f:
                seeds = json.loads(f.read())

        liste = []
        [liste.append(s) for s in seeds if s[0] == "NTM"]
        seeds = liste[:100]

        test = Analysis(seeds)



#!------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
