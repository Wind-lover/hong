#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Post-processing the results from fatigue analysis
#
#
# Authors: Hao BAI
# Date: 29/10/2018
#
# Version:
#   - 0.0: Initial version reserved for DLC1.1
#
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
from matplotlib import pyplot as plt
from matplotlib.ticker import PercentFormatter
import json
import math
# import sys
# import csv
import numpy as np
import collections
# import multiprocessing
# from scipy import signal



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class Damage(object):
    ''' Find extrema in FAST output file
        Attributes:
                      
        Methods:
            
    '''
    def __init__(self, filebase, echo):
        # attributes from input
        self.filebase = filebase
        self.echo = echo
        # new attributes
        self.dataInput = None
        self.maxDamage = None
        self.maxSpot = None
        # run methods
        self.load()
        self.getMax()

    def load(self):
        with open(self.filebase+'.dam', 'r') as f:
            self.dataInput = json.loads(f.read())

    def getMax(self):
        allDamages = [value['Dcumulate'] for value in self.dataInput.values()]
        self.maxDamage = max(allDamages)
        self.maxSpot = [key for (key, value) in self.dataInput.items() 
                        if value['Dcumulate'] == self.maxDamage][0]


class Analysis(object):
    ''' Cross wind speed study
    '''
    def __init__(self, seeds, echo):
        self.seeds = seeds
        self.echo = echo

        self.listOfSpeed = []
        self.dataInput = collections.OrderedDict()

        self.load()

    def load(self):
        # recover list of mean wind speeds
        listOfSpeed = list(set([int(s[1]) for s in self.seeds]))
        listOfSpeed.sort()
        self.listOfSpeed = [str(v) for v in listOfSpeed]
        # initiate structure of input data
        for v in self.listOfSpeed:
            self.dataInput[v] = {'InputDamageFile':collections.deque(),
                                 'MaxSpots':collections.deque(),
                                 'Occurence':[],
                                 'MaxSpot':'',
                                 'MeanDamages':collections.deque()}
        # read data from file
        for s in self.seeds:
            d = Damage('{}_{}mps_{}'.format(s[0], s[1], s[2]), False)
            self.dataInput[s[1]]['InputDamageFile'].append(d)
            self.dataInput[s[1]]['MaxSpots'].append(d.maxSpot)
    
    def selectSpot(self):
        for v in self.listOfSpeed:
            data = self.dataInput[v]['MaxSpots']
            spotNames = set(data)
            self.dataInput[v]['Occurence'] = [(name, data.count(name)) for name in spotNames]
            self.dataInput[v]['MaxSpot'] = max(self.dataInput[v]['Occurence'], key=lambda x:x[1])
        
        if self.echo:
            print('Wind speed (m/s)\tSpot\tOccurence (/{})'.format(
                                              int(len(self.seeds)/len(self.listOfSpeed))))
            for v in self.listOfSpeed:
                print('{}\t{}\t{}'.format(v, self.dataInput[v]['MaxSpot'][0],
                                                         self.dataInput[v]['MaxSpot'][1]))
    
    def plotDamageOnSpot(self, speed, spot, axisInput=None, bins=20):
        data = collections.deque()
        data = [file.dataInput[spot]['Dcumulate']
                                     for file in self.dataInput[speed]['InputDamageFile']]
        if axisInput is None:
            fig, axis = plt.subplots()
        else:
            axis = axisInput
        # Normalize inputs by the total number of counts
        N, bins, patches = axis.hist(data, bins=bins, weights=np.ones(len(data))/len(data))
        axis.yaxis.set_major_formatter(PercentFormatter(1)) # convert to percentage
        axis.ticklabel_format(style='sci',scilimits=(-3,4),axis='x')
        if axisInput is None:
            axis.set_title('Distribution of damage at wind speed {} m/s on section spot {}'
                           .format(speed, spot))
            axis.set_xlabel('Cumulative damage during simulated time (10 min)')
            axis.set_ylabel('Probability')
            plt.show()
        else:
            axis.set_title('{} m/s {}°'.format(speed, spot), pad=-15)

    def plotDamageForAllSpeeds(self, bins=20):
        fig, axes = plt.subplots(3, 4, sharex=False, sharey=True, tight_layout=False)
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            spot = self.dataInput[v]['MaxSpot'][0]
            self.plotDamageOnSpot(v, spot, ax, bins)
        # Common axes lables
        plt.subplots_adjust(left=0.06, bottom=0.10, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
        fig.suptitle('Distribution of damage at different wind speed')
        fig.text(0.5, 0.03, 'Cumulative damage during simulated time (10 min)', ha='center', va='center')
        fig.text(0.02, 0.5, 'Probability', ha='center', va='center', rotation='vertical')
        plt.show()

    def meanDamageOnGage(self, speed):
        data = collections.OrderedDict()
        # initiate data structure
        for key in self.dataInput[speed]['InputDamageFile'][0].dataInput.keys():
            data[key] = collections.deque()
        # get damage values
        for file in self.dataInput[speed]['InputDamageFile']:
            for (key, value) in file.dataInput.items():
                data[key].append(value['Dcumulate'])
        # calculate mean value
        for (key, value) in data.items():
            mean = sum(value)/len(value)
            self.dataInput[speed]['MeanDamages'].append((key,mean))

    def meanDamageForAllSpeeds(self):
        [self.meanDamageOnGage(v) for v in self.listOfSpeed]

    def plotMeanDamageOnGage(self, speed, gage, axisInput=None):
        # get and sort data
        temp = collections.deque()
        for elem in self.dataInput[speed]['MeanDamages']:
            if elem[0][4] == gage:
                temp.append( (math.radians(float(elem[0][6:])), elem[1]) )
        temp = list(temp)
        temp.sort()
        # decompose to vectors for plotting
        X = collections.deque()
        Y = collections.deque()
        for elem in temp:
            X.append(elem[0])
            Y.append(elem[1])
        X.append(X[0]) # in order to close circle in radar graph
        Y.append(Y[0])
        # normolize the average of cumulative damage by its maximum value
        Ynormed = [y/max(Y) for y in Y]
        # plot in polar coordinates
        if axisInput is None:
            axis = plt.subplot(111, polar=True)
        else:
            axis = axisInput
        axis.plot(X, Ynormed, 'o-')
        # axis.set_rmax(1e-9)
        plt.thetagrids(range(0,360,30)) # change theta gridlines
        # plt.xticks(range(0,360,30))
        if axisInput is None:
            axis.fill(X, Ynormed)
            axis.set_title('Distribution of mean damage at wind speed {} m/s on tower gage {}'
                           .format(speed, gage))
            # axis.set_xlabel('Angle of θ (°)')
            plt.show()
        else:
            axis.set_title('{} m/s gage {}'.format(speed, gage), pad=-30)

    def plotMeanDamageForAllSpeeds(self):
        fig, axes = plt.subplots(3, 4, sharex='all', sharey='all', tight_layout=False,
                                 subplot_kw=dict(projection='polar'))
        # The minor subplots
        axes = [axis for ax in axes for axis in ax]
        for (ind,ax) in enumerate(axes):
            v = self.listOfSpeed[ind]
            spot = self.dataInput[v]['MaxSpot'][0]
            self.plotMeanDamageOnGage(v, spot[4], ax)
        # Common axes lables
        plt.subplots_adjust(left=0.06, bottom=0.06, right=0.94, top=0.94, wspace=0.14, hspace=0.14)
        fig.suptitle('Distribution of mean damage at different wind speed')
        fig.text(0.5, 0.03, 'Perimeter: angle of θ (°)', ha='center', va='center')
        fig.text(0.02, 0.5, 'Radius: Average of cumulative damage in {} runs (normolized)'
                            .format( int(len(self.seeds)/len(self.listOfSpeed)) ),
                            ha='center', va='center', rotation='vertical')
        plt.show()

#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------




#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
@utils.timer
def main():
    essai = 2

    if essai == 1:
        test = Damage('NTM_25mps', False)
        print(test.maxDamage, test.maxSpot)

    if essai == 2:
        with utils.cd('~/Eolien/Parameters/NREL_5MW_Onshore/Wind'):
            with open('100seeds.json', 'r') as f:
                seeds = json.loads(f.read())

        liste = []
        [liste.append(s) for s in seeds if s[0] == "NTM"]
        seeds = liste[:100]

        test = Analysis(seeds)


#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
