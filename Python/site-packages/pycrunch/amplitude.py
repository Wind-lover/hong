#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Seek peak and valley value in time series data and calculate amplitude
#
#
# Authors: Hao BAI
# Date: 17/10/2018
#
# Version:
#   - 0.0: Initial version
#   - 0.1: Change codes to make a site-package
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import csv
# import copy, os
import numpy
from scipy import signal
# import json
# import pandas, time, collections
# from scipy import signal
# from contextlib import contextmanager
# import numpy as np
# import multiprocessing



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class finder(object):
    ''' Find extrema in FAST output file
        Attributes:
            filebase: basename of .out file (i.e. name without extension) [str]
            header: line number that contains column's name in input file [int]
            datarow: line number that contains the first row of data in input file [int]
            startline: begin writting results from this row in output file [int]
            parameters: channel names that will be used for searching [list]            
        Methods:
            find(): 
    '''
    def __init__(self, filebase, header, datarow, startline, parameters):
        self.filebase = filebase
        self.header = header
        self.datarow = datarow
        self.startline = startline
        self.parameters = parameters

        self.fieldunitsOutput = {}
        self.datareader = None
        self.dataInput = {}
        self.stressFilter = {}

    def run(self, echo=True):
        print("Extrema finder v0.1 (October 17 2018)")
        if echo: print("|- Importing "+self.filebase+" ...")
        self.dataInput = utils.readcsv(filename=self.filebase+'.out', header=self.header,
                                       datarow=self.datarow, echo=echo)
        # searching peak/valley upon each channel
        for para in self.parameters:
            if echo: print("|- Searching local maximum and minimum of {}...".format(para))
            dataOutput = self.find(para)
            if echo: print("|- Saving data ...")
            self.save(para, dataOutput)
        print("|- The peak and valley of channel {} in {} are exported !".format(
              self.parameters, self.filebase))

    def find(self, channelname, peak=True, valley=True):
        ''' Searching peak and/or valley values
            Input:
                peak: True/False to find peak value (i.e. local maximum) [boolean]
                valley: True/False to find valley value (i.e. local minimum) [boolean]
        '''
        dataOutput = []
        timeseries = numpy.array(self.dataInput.get(1)['Records'])

        for key, value in self.dataInput.data.items():
            if channelname in value['Title']:
                data = numpy.array(value['Records'])
                maxima = signal.argrelextrema(data, numpy.greater_equal, order=10) # find maxima
                result = list(data[maxima[0]])
                timestep = list(timeseries[maxima[0]])
                for i in range(len(result)):
                    dataOutput.append( {'Time      ':"{:^10}".format(timestep[i]), 'Maxi/Mini ':"{:^10.3E}".format(result[i])} )

                minima = signal.argrelextrema(data, numpy.less_equal, order=10) # find minima
                result = list(data[minima[0]])
                timestep = list(timeseries[minima[0]])
                for i in range(len(result)):
                    dataOutput.append( {'Time      ':"{:^10}".format(timestep[i]), 'Maxi/Mini ':"{:^10.3E}".format(result[i])} )
        
        dataOutput.sort(key=lambda x:float(x['Time      ']), reverse=False)
        return dataOutput

    def save(self, channelname, dataOutput):
        filename = self.filebase+'_'+channelname+'.ext'

        # Create the title line
        fieldnamesOutput = []
        fieldnamesOutput.append('Time      ')
        fieldnamesOutput.append('Maxi/Mini ')

        # Create the unit line
        fieldunitsOutput = {}
        fieldunitsOutput['Time      '] = "{:^10}".format("(s)")
        fieldunitsOutput['Maxi/Mini '] = "{:^10}".format("(-)")
        
        # Save result to the file
        with open(filename, 'wt') as f:            
            for i in range(self.startline-1): # skip empty lines
                f.write("\n")

            datawriter=csv.DictWriter(f, delimiter='\t', fieldnames=fieldnamesOutput)
            self.datawriter = datawriter

            datawriter.writeheader() # channel titles

            datawriter.writerow(self.fieldunitsOutput) # channel units
            for row in dataOutput:
                datawriter.writerow(row)


#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------




#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    myfinder = finder(filebase="../tools/csv", header=7, datarow=9, startline=12, parameters=["TwrBsFyt",])
    myfinder.run()


#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
