#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Seek peak and valley value in time series data and calculate amplitude
#
#
# Authors: Hao BAI
# Date: 17/10/2018
#
# Version:
#   - 0.0: Initial version
#   - 0.1: Change codes to make a site-package
#   - 0.2: Enable possibility of multiprocessing
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import csv
import numpy
import collections
import multiprocessing
from scipy import signal



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class PeakValleyFinder(object):
    ''' Find extrema in FAST output file
        Attributes:
            filebase: basename of .out file (i.e. name without extension) [str]
            header: line number that contains column's name in input file [int]
            datarow: line number that contains the first row of data in input file [int]
            startline: begin writting results from this row in output file [int]
            channels: channel names that will be used for searching [list]            
        Methods:
            find(): search peak/valley for a given channel name
            run(): batch profile for finding processing
    '''
    def __init__(self, filebase, header, datarow, startline, channels, peak, valley,echo):
        self.filebase = filebase
        self.header = header
        self.datarow = datarow
        self.startline = startline
        self.channels = channels
        self.peak = peak
        self.valley = valley
        self.dataInput = None

        self.run(echo)

    def run(self, echo):
        print("Extrema Finder v0.2 (October 17 2018)")
        if echo: print("|- Importing "+self.filebase+" ...")
        self.dataInput = utils.readcsv(filename=self.filebase+'.out', header=self.header,
                                       datarow=self.datarow, echo=echo)
        # searching peak/valley upon each channel
        for para in self.channels:
            if echo: print("|- Searching local maximum/minimum of {}...".format(para),
                           end="")
            dataOutput = self.find(para)
            if echo: print(" Done !")
            self.save(para, dataOutput)
        print("|- The peak and valley of channel {} in {} are exported !".format(
              self.channels, self.filebase))

    def find(self, channelname):
        ''' Searching peak and/or valley values
            Input:
                peak: True/False to find peak value (i.e. local maximum) [boolean]
                valley: True/False to find valley value (i.e. local minimum) [boolean]
        '''
        dataOutput = collections.deque()
        timeline = numpy.array(self.dataInput.get(1)['Records'])
        # check whether the channel is containted in input data
        if channelname in self.dataInput.data.keys():
            data = numpy.array(self.dataInput.data.get(channelname)['Records'])
            if self.peak: # find maxima
                maxima = signal.argrelextrema(data, numpy.greater_equal, order=10)
                result = list(data[maxima[0]])
                timestep = list(timeline[maxima[0]])
                for i in range(len(result)):
                    dataOutput.append( {'Time':"{:^10}".format(timestep[i]),
                                        'Peak/Valley':"{:^10.3E}".format(result[i])} )
            if self.valley: # find minima
                minima = signal.argrelextrema(data, numpy.less_equal, order=10)
                result = list(data[minima[0]])
                timestep = list(timeline[minima[0]])
                for i in range(len(result)):
                    dataOutput.append( {'Time':"{:^10}".format(timestep[i]),
                                        'Peak/Valley':"{:^10.3E}".format(result[i])} )
        else:
            raise Exception("[Error] There is no channel named {} in input data".format(
                            channelname))
        # sort output data by time in order of increasing [deque -> list]
        dataOutput = sorted(dataOutput, key=lambda x:float(x['Time']), reverse=False)
        return dataOutput

    def save(self, channelname, dataOutput):
        # Creat the output filename
        filename = self.filebase+'_'+channelname+'.ext'
        # Create the title line
        fieldnames = []
        fieldnames.append('Time')
        fieldnames.append('Peak/Valley')
        # Create the unit line
        fieldunits = {}
        fieldunits['Time'] = "{:^10}".format("(s)")
        fieldunits['Peak/Valley'] = "{:^10}".format("(-)")        
        # Save result to the file
        with open(filename, 'wt') as f:            
            for i in range(self.startline-1): # skip empty lines
                f.write("\n")
            datawriter=csv.DictWriter(f, delimiter='\t', fieldnames=fieldnames)
            datawriter.writeheader() # write channel names
            datawriter.writerow(fieldunits) # write channel units
            for row in dataOutput: # write channel values
                datawriter.writerow(row)


class Amplitude(object):
    ''' Operate peak-to-peak amplitude
        Attributes:
            
        Methods:
            
    '''
    def __init__(self, filelist):
        pass

    @classmethod
    def calculate_p2p_amplitude(self, filename):
        ''' Calculate peak-to-peak amplitude between peak and valley
            Attention ! The input data should have been sorted by increasing or decreasing
            order.
            Input:
                filename: name of file to be opened [string]
        '''
        data = utils.readfwf(filename, echo=False)

        listResult = []
        for index, value in enumerate(data.get(2)['Records']):
            if index != 0:
                startTime = data.get(1)['Records'][index-1]
                endTime = data.get(1)['Records'][index]
                diffTime = round(endTime - startTime, 2)
                diffValue = round(data.get(2)['Records'][index] - data.get(2)['Records'][index-1], 4)

                result = (startTime, endTime, diffTime, diffValue)
                listResult.append(result)
        # sort result from the largest amplitude to the smallest
        listResult.sort(key=lambda x:abs(x[-1]), reverse=True)
        return listResult

    @classmethod
    def max_p2p_amplitude(self, list_filebase, channels, extension='.ext', echo=False):
        result = []
        for ch in channels:
            data = []
            for file in list_filebase:
                filename = file+'_'+ch+extension
                list_amplitude = self.calculate_p2p_amplitude(filename)
                data.append( {'File':file, ch:list_amplitude[0]} )
            # find the maximum case for the current channel
            data.sort(key=lambda x:abs(x[ch][-1]), reverse=True)
            result.append(data[0])
        
        if echo:
            for elem in result:
                print(elem)

        return result



#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
def find_peak_valley(filebase, header, datarow, startline, channels, peak=True, 
                     valley=True, echo=True):
    temp = PeakValleyFinder(filebase, header, datarow, startline, channels, peak, 
                            valley, echo)


def find_peak_valley_multiprocess(list_filebase, header, datarow, startline, channels, 
                                  peak=True, valley=True, echo=False):
    pool = multiprocessing.Pool()
    [pool.apply_async(find_peak_valley, args=(filebase, header, datarow, startline,
                           channels, peak, valley, echo)) for filebase in list_filebase]
    pool.close()
    pool.join()



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    # find_peak_valley('NTM_3mps_-1325143789', header=7, datarow=6009, startline=12,
    #                  channels=['Time',])
    # find_peak_valley('NTM_3mps_-1325143789', 7, 6009, 12, ['Wind1VelX','Wind1VelY',])
    # find_peak_valley_multiprocess(['NTM_3mps_-1325143789', 'NTM_3mps_-1431633139'], 7, 6009, 12, ['YawBrTDxt', 'TwHt4FLxt', 'TwrBsMyt'])
    
    filelist = ['NTM_3mps_-1325143789', 'NTM_3mps_-1431633139']
    Amplitude.max_p2p_amplitude(filelist, ['YawBrTDxt', 'TwHt4FLxt', 'TwrBsMyt',], '.ext', True)
    pass



#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
