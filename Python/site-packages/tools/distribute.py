#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Distribute computing tasks
#
#
# Authors: Hao BAI
# Date: 01/11/2018
#
# Version:
#   - 0.0: Initial version
#   - 0.1: Valid version
#   - 0.2: Split tasks according to a fixed ratio based on computing power
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================
from tools import utils
#*============================== Modules Communs ==============================
import math
import platform
from collections import OrderedDict

#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
class LMN(object):
    ''' Computers in Laboratoire de Mécanique de Normandie
        Attributes:
            nodes: available computer names [list]
        Methods:
            get(): get tasks by channel name or channel number
    '''
    def __init__(self, echo=True):
        self.echo = echo
        self._nodes = OrderedDict()
        self._nodes['PC-LMR-O7010B'] = [1] # Hao BAI
        self._nodes['PC-LMN-7050'] = [2] # Chao REN
        self._nodes['PC-LMN-7040'] = [3]
        self._nodes['PC-LMN-9010'] = [4] # Changwu HUANG
        # self._nodes['PC-LMN-1600A'] = [5] # Surke ALJAMEL
        # self._nodes['PC-LMN-1600B'] = [6] # Corentin LOTHODE
        # self._nodes['PC-LMN-9020'] = [7] # Shubiao WANG
        self._nodes['PC-LMN-9020A'] = [8]
        self._nodes['PC-LMN-9020B'] = [9]

        self._timePerTask = {'PC-LMR-O7010B':717, # Hao BAI
                             'PC-LMN-7050':567, # Chao REN
                             'PC-LMN-7040':566,
                             'PC-LMN-9010':923, # Changwu HUANG
                            #  'PC-LMN-1600A':710, # Surke ALJAMEL
                            #  'PC-LMN-1600B':707, # Corentin LOTHODE
                            #  'PC-LMN-9020':719, # Shubiao WANG
                             'PC-LMN-9020A':700,
                             'PC-LMN-9020B':698,
                            }
        self._quota = OrderedDict.fromkeys(self._nodes.keys(), None)
        self._length = OrderedDict.fromkeys(self._nodes.keys(), None)
        self._allocation = OrderedDict.fromkeys(self._nodes.keys(), None) # number of tasks to be allocated
        self._currentComputer = platform.node()

        if self.echo:
            print('Distributed Computing v0.2 (November 1 2018)')
            print('========== Pre-processing ==========')

    def setIndividually(self, computerName, tasks):
        self._nodes[computerName] = tasks
        self._length[computerName] = len(tasks)
        estimateTime = self._timePerTask[computerName] * math.ceil(self._length[computerName]/8)
        formatedTime = utils.format_seconds(estimateTime)
        print('|- {} tasks are affected to computer {} and wished to terminate in {}'
              .format(self._length[computerName], computerName, formatedTime))

    def setEqually(self, tasks):
        tasksLength = len(tasks)
        chunkLength = int(tasksLength/len(self._nodes))
        for key in self._nodes.keys():
            self._allocation[key] = chunkLength
        # add the residue task to the most powerful computer
        cumulLength = len(self._nodes) * chunkLength
        if cumulLength != tasksLength:
            residue = tasksLength - cumulLength
            self._allocation[key] = self._allocation[key] + residue
        print('{} tasks will be equally splited into {} partitions'.format(tasksLength,
              len(self._nodes)))
        self._allocate(tasks)

    # TODO: allocate tasks by chunk of 8
    def setAutomatically(self, tasks):
        # calculate distribution quota of every computer
        self._calculateQuota()
        # divide tasks into partitions
        tasksLength = len(tasks)
        cumulLength = 0
        for key in self._nodes.keys():
            numberOfTasks = int(round(tasksLength*self._quota[key],0))
            self._allocation[key] = numberOfTasks
            cumulLength = cumulLength + numberOfTasks
        # add the residue task to a computer
        if cumulLength != tasksLength:
            residue = tasksLength - cumulLength
            self._allocation[key] = self._allocation[key] + residue
        print('{} tasks will be splited into {} partitions based on computing power'
              .format(tasksLength, len(self._nodes)))
        self._allocate(tasks)

    def _calculateQuota(self):
        totalPower = sum([1/v for v in self._timePerTask.values()])

        for (key, value) in self._timePerTask.items():
            self._quota[key] = (1/value) / totalPower

    def _allocate(self, tasks):
        # allocate tasks to computers
        for (key, value) in self._allocation.items():
            chunk = tasks[:value]
            tasks = tasks[value:]
            self.setIndividually(key, chunk)

    def show(self):
        for (key, value) in self._nodes.items():
            print('|- {} refers to a {} of length {}'.format(key,type(value),
                  self._length[key]))

    def run(self, function, *args):
        if self.echo:
            print('You are running on computer {}'.format(self._currentComputer))
            print('Function {} will be called {} times'.format(function,
                  self._length.get(self._currentComputer)))
            print('========== Computing Starts ==========')
        # execution
        if self._nodes.get(self._currentComputer) is None:
            raise Exception("|- [ERROR] The computer {} is an unknown device".format(
                            self._currentComputer))
        else:
            tasks = self._nodes.get(self._currentComputer)
            if len(args) == 0: function(tasks)
            if len(args) == 1: function(tasks, args[0])
            if len(args) == 2: function(tasks, args[0], args[1])
            if len(args) == 3: function(tasks, args[0], args[1], args[2])
            if len(args) == 4: function(tasks, args[0], args[1], args[2], args[3])



#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
def testFunction():
    pass



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    test = LMN()
    tasks=[1]*10
    test.setAutomatically(tasks)
    # test.show()



#!----------------------------------------------------------------------------------------
#!                                         EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
