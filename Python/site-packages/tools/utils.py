#!/usr/bin/env python
# -*- coding: utf-8 -*-

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Some common useful functions
#
#
# Authors: Hao BAI
# Date: 17/10/2018
#
# Version:
#   - 0.0: Initial version
#   
# Comments:
# 
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



#!----------------------------------------------------------------------------------------
#!                                          MODULES PRÉREQUIS
#!----------------------------------------------------------------------------------------
#*============================== Modules Personnels ==============================

#*============================== Modules Communs ==============================
# import csv, copy, os
# import numpy, json
import pandas, time, collections
# from scipy import signal
from contextlib import contextmanager
# import numpy as np
# import multiprocessing



#!----------------------------------------------------------------------------------------
#!                                         CLASS
#!----------------------------------------------------------------------------------------
@contextmanager
def cd(newdir):
    prevdir = os.getcwd() # save current working path
    os.chdir(os.path.expanduser(newdir)) # change directory
    try:
        yield
    finally:
        os.chdir(prevdir) # revert to the origin workinng path



#!----------------------------------------------------------------------------------------
#!                                      FUNCTIONS
#!----------------------------------------------------------------------------------------
def frange(start, stop=None, step=None, precision=None):
    ''' Return a list of float numbers
        Syntax:
            range(stop)
            range(start, stop[, step][, precision])
    '''
    # check how many inputs
    if stop is None and step is None and precision is None:
        return frange(0.0, start)
    # set default step
    if step is None:
        temp = str(stop).lstrip('1234567890')
        if temp == '':
            step = 1.0
        else:
            step = 10**(-(len(temp)-1))
    # set default precision
    if precision is None:
        fois = 1e7
    else:
        fois = 10**precision
    # amplify float number to int number
    new_start = int(start * fois)
    new_stop = int(stop * fois)
    new_step = int(step * fois)
    r = range(new_start, new_stop, new_step)
    # convert int number to float number
    l = [i/fois for i in r]
    return l


def readcsv(filename, delimiter='\t', header=7, datarow=9, echo=True):
    ''' Read a csv-like file into ordered dictionary
        Syntax:
            readcsv(filename[, delimiter[, header[, datarow[, echo]]]])
        Parameters:
            filename: name of file to be opened [string]
            delimiter: seperator [string]
            header: line number that contains column's name [int]
            datarow: line number that contains the first row of data [int]
            echo: True/False to print elapsed time on screen [boolean]
    '''
    TIK = time.time()
    data = collections.OrderedDict()
    header = header - 1
    datarow = datarow - 1
    # read file by using padas
    dataframe = pandas.read_csv(filename, delimiter=delimiter, encoding='ISO-8859-1',
                                header=header, skip_blank_lines=False)
    # don't use set low_memory=False, dtype=str => will be slower
    # skip rows between header and datarow
    if datarow-header >= 2:
        endIndex = (datarow-header)-1
        dataframe.drop(list(range(endIndex)), inplace=True)
    # read data column by column
    for i in range(dataframe.columns.size):
        name = dataframe.columns[i] # get the column head
        records = dataframe.iloc[:,i].values.astype('float') # get column values in float
        data[i+1] = {'Title':name, 'Records':list(records)}
    TOK = time.time()
    if echo: print("|-", filename, "loaded in", "%.2f"%(TOK-TIK), "s")
    return data


def readfwf(filename, widths=(11,11), header=12, datarow=14, echo=True):
    ''' Read a fixed-width formatted file into ordered dictionary
        Syntax:
            readfwf(filename[, widths[, header[, datarow[, echo]]]])
        Parameters:
            filename: name of file to be opened [string]
            widths: list of field widths [list of int]
            header: line number that contains column's name [int]
            datarow: line number that contains the first row of data [int]
            echo: True/False to print elapsed time on screen [boolean]
    '''
    TIK = time.time()
    data = collections.OrderedDict()
    header = header - 1
    datarow = datarow - 1
    dataframe = pandas.read_fwf(filename, widths=widths, header=header)
    # skip rows between header and datarow
    if datarow-header >= 2:
        endIndex = (datarow-header)-1
        dataframe.drop(list(range(endIndex)), inplace=True)
    # read data column by column
    for i in range(dataframe.columns.size):
        name = dataframe.columns[i] # get the column head
        records = dataframe.iloc[:,i].values.astype('float') # get column values in float
        data[i+1] = {'Title':name, 'Records':list(records)}
    TOK = time.time()
    if echo: print("|-", filename, "loaded in", "%.2f"%(TOK-TIK), "s")
    return data



#!----------------------------------------------------------------------------------------
#!                                     MAIN FUNCTION
#!----------------------------------------------------------------------------------------
def main():
    print("frange(3) =",frange(3))
    print("frange(3,5) =",frange(3,5))
    print("frange(3,4.02) =",frange(3,4.02))
    print("frange(5,9,2) =",frange(5,9,2))
    print("frange(5,7,0.5) =",frange(5,7,0.5))
    print("-----")

    test = readcsv('csv.out')
    print(test)
    test = readfwf('fwf.ext')
    print(test)



#!----------------------------------------------------------------------------------------
#                                               EXÉCUTION
#!----------------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
